# -*- coding: utf-8 -*-
"""Darknet_19_model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ceu_dcVygQHamrWG50c3km8FK0oUrw7a
"""

#Here is the full implementation of darknet_19...

import torch
import torch.nn as nn
from torch.nn import functional as F

Architecture=[(3,32,3,1,1),
               "Max_pool",
              (32,64,3,1,1),
              "Max_pool",
              (64,128,3,1,1),
              (128,64,1,1,0),
              (64,128,3,1,1),
               "Max_pool",
              (128,256,3,1,1),
              (256,128,1,1,0),
              (128,256,3,1,1),
               "Max_pool",
              [(256,512,3,1,1),(512,256,1,1,0),1],
              (256,512,3,1,1),
              "Max_pool",
              [(512,1024,3,1,1),(1024,512,1,1,0),1],
              (512,1024,3,1,1),
              (1024,1000,1,1,0), #last layer...
              "Global_average_pooling"
              ]

class Conv_Operation(torch.nn.Module):
  def __init__(self,input,output, filter_size, stride, padding):
    super(Conv_Operation,self).__init__()
    self.Conv=torch.nn.Conv2d(input,output,filter_size, stride=stride, padding=padding)
    self.norm=torch.nn.BatchNorm2d(output) #yes we need batch normalization
    self.Relu= torch.nn.ReLU()


  def forward(self, input):
    input= self.Conv(input)
    input= self.norm(input)
    input= self.Relu(input)

    return input

class CSP_Darknet_53(torch.nn.Module):
  def __init__(self):
    super(CSP_Darknet_53,self).__init__()
    self.layers= torch.nn.ModuleList()
    self.architecture= Architecture
    for i in range(len(self.architecture)):

      if type(self.architecture[i])==tuple:

        self.layers.append(Conv_Operation(self.architecture[i][0],self.architecture[i][1],self.architecture[i][2],self.architecture[i][3],self.architecture[i][4]))


      if type(self.architecture[i])==str and self.architecture[i]=="Max_pool":

        self.layers.append(torch.nn.MaxPool2d(kernel_size=2, stride=2))


      elif type(self.architecture[i])==str and self.architecture[i]=="Global_average_pooling":
        self.layers.append(torch.nn.AdaptiveAvgPool2d(output_size=(1, 1)))




      if type(Architecture[i])==list:

        for j in range(self.architecture[i][2]):
          Convolution=self.architecture[i]
          Convolution_1= Convolution[0]
          Convolution_2= Convolution[1]

          self.layers.append(Conv_Operation(Convolution_1[0],Convolution_1[1],Convolution_1[2],Convolution_1[3],Convolution_1[4]))
          self.layers.append(Conv_Operation(Convolution_2[0],Convolution_2[1],Convolution_2[2],Convolution_2[3],Convolution_2[4]))







  def forward(self,x):
    for layer in self.layers:
      x= layer(x)
      print("output of layers:",x.shape)

    return x



#so here it work properly..
if __name__== "__main__":
    model = CSP_Darknet_53()
    # Sample input tensor with batch size of 1 and image size 416x416
    y= torch.randn(1,3,224,224)
    output_y= model(y)
    print("Output shape of y with the input shape is:(1,3,224,224)",output_y.shape)

