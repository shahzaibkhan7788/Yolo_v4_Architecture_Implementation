# -*- coding: utf-8 -*-
"""Darknet_53.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-ISMOFBy5DKEyikLsgv0J_VE_IrKqHta
"""

#Here is the full implementation of darknet_53 Architecture...
import torch
import torch.nn as nn
from torch.nn import functional as F

#implmentation of Darknet 53 is also completed

Architecture=[(3,32,3,1,1),

              (32,64,3,2,1), #reduction occur ...
              ["Residual_block",64,32,64,1], #First Residual Block..
              (64,128,3,2,1), #reduction occur ...
              ["Residual_block",128,64,128,2], #Second Residual Block with 2 times iterations
              (128,256,3,2,1), #reduction occur ...
              ["Residual_block",256,128,256,8], #Third Residual Block with 8 times iterations
              (256,512,3,2,1), #reduction occur
              ["Residual_block",512,256,512,8], #Fourth Residual Block with 8 times iterations
              (512,1024,3,2,1), #reduction occur
              ["Residual_block",1024,512,1024,4] #Fifth Residual Block with 8 times iteration

              ]


              #One question ..does the block get its previous result truely..check it....

class Conv_Operation(torch.nn.Module):
  def __init__(self,input,output, filter_size, stride, padding):
    super(Conv_Operation,self).__init__()
    self.Conv=torch.nn.Conv2d(input,output,filter_size, stride=stride, padding=padding)
    self.norm=torch.nn.BatchNorm2d(output) #yes we need batch normalization
    self.Relu= torch.nn.ReLU()


  def forward(self, input):
    input= self.Conv(input)
    input= self.norm(input)
    input= self.Relu(input)

    return input

class Residual_block(torch.nn.Module):
  def __init__(self,input_filters,Inner_filters, output_filters):
    super(Residual_block,self).__init__()
    self.Conv_1=torch.nn.Conv2d(in_channels=input_filters, out_channels=Inner_filters, kernel_size=(1,1), stride=1, padding=0)
    self.Conv_2=torch.nn.Conv2d(in_channels=Inner_filters, out_channels=output_filters, kernel_size=(3,3), stride=1, padding=1)
    self.norm_1=torch.nn.BatchNorm2d(Inner_filters) #yes we need batch normalization
    self.norm_2=torch.nn.BatchNorm2d(output_filters) #yes we need batch normalization
    self.Relu_1= torch.nn.ReLU()
    self.Relu_2= torch.nn.ReLU()




  def forward(self, x):
    input= self.Relu_1(self.norm_1(self.Conv_1(x)))
    input= self.Relu_2(self.norm_2(self.Conv_2(input)))

    return x + input

class Darknet_53(torch.nn.Module):
  def __init__(self):
    super(Darknet_53,self).__init__()
    self.layers= torch.nn.ModuleList()
    self.architecture= Architecture
    for i in range(len(self.architecture)):

      if type(self.architecture[i])==tuple:

        self.layers.append(Conv_Operation(self.architecture[i][0],self.architecture[i][1],self.architecture[i][2],self.architecture[i][3],self.architecture[i][4]))




      if type(self.architecture[i])==list and self.architecture[i][0]=="Residual_block":
        for j in range(self.architecture[i][4]):
          Residual= self.architecture[i]
          self.layers.append(Residual_block(Residual[1],Residual[2],Residual[3]))






  def forward(self,x):
    for layer in self.layers:
      x= layer(x)
      print("output of layers:",x.shape)

    return x



#so here it work properly..
if __name__== "__main__":
    model = Darknet_53()
    # Sample input tensor with batch size of 1 and image size 416x416
    x = torch.randn(1, 3, 416, 416)
    output_x = model(x)
    print("Output shape of x with the input shape is:(1, 3, 608, 608)",output_x.shape)

